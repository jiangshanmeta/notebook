(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{440:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"减少http请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#减少http请求"}},[t._v("#")]),t._v(" 减少HTTP请求")]),t._v(" "),s("h2",{attrs:{id:"图片地图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图片地图"}},[t._v("#")]),t._v(" 图片地图")]),t._v(" "),s("p",[t._v("这项技术是针对图片的，可以利用map/area标签把图片分割为多个部分，每个部分有自己独立的行为。这样可以用单张图片代替多张图片，减少HTTP请求次数。不过这项古老的技术现在不多见了。")]),t._v(" "),s("h2",{attrs:{id:"css-sprites"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-sprites"}},[t._v("#")]),t._v(" CSS Sprites")]),t._v(" "),s("p",[t._v("CSS Sprites主要应用在一个小icon图标上，把它们合并为一张图而不是一个icon一个图(减少HTTP请求次数)，再利用"),s("code",[t._v("background-position")]),t._v("属性找到对应的图标。")]),t._v(" "),s("h2",{attrs:{id:"内联图片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内联图片"}},[t._v("#")]),t._v(" 内联图片")]),t._v(" "),s("p",[t._v("这种方法是把图片转换为data-url的形式而不是单独的文件，保存到HTML或CSS中，减少对图片的请求。")]),t._v(" "),s("p",[t._v("现在webpack的url-loader可以辅助处理这个问题，可以限制文件大小，文件比较小转换为data-url的形式，文件比较大依然是单独图片文件。")]),t._v(" "),s("p",[t._v("这一技术可以减少HTTP请求，但是如果跨页面不能缓存图片(相较于独立图片文件)，会使得总加载量变大。如果在CSS中使用内联图片，CSS文件被缓存则包含的图片被缓存。")]),t._v(" "),s("h2",{attrs:{id:"合并脚本和样式表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并脚本和样式表"}},[t._v("#")]),t._v(" 合并脚本和样式表")]),t._v(" "),s("p",[t._v("合并js和css文件有利于减少HTTP请求，但是不利于开发维护。所以开发依然是模块化开发，但是最终利用webpack这样的工具生成合并后的文件。")])])}),[],!1,null,null,null);a.default=e.exports}}]);
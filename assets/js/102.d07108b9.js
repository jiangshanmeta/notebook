(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{505:function(t,e,a){"use strict";a.r(e);var v=a(42),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"内存控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存控制"}},[t._v("#")]),t._v(" 内存控制")]),t._v(" "),a("h2",{attrs:{id:"v8的垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8的垃圾回收"}},[t._v("#")]),t._v(" V8的垃圾回收")]),t._v(" "),a("p",[t._v("在V8中，主要将内存分为新生代和老生代两部分。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。")]),t._v(" "),a("p",[t._v("对于新生代的垃圾回收，主要通过Scavenge算法进行垃圾回收。它将内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。")]),t._v(" "),a("p",[t._v("Scavenge的缺点是只能使用堆内存的一半，但是由于只复制存活对象，且对于生命周期短的场景(新生代)存活对象只占少部分。")]),t._v(" "),a("p",[t._v("当一个对象多次复制依然存活，会被认为是生命周期较长的对象。这种较长生命周期的对象会被移动到老生代中。")]),t._v(" "),a("p",[t._v("老生代的垃圾回收采用Mark-Sweep & Mark-Compact。对于老生代内存，对象生命周期较长，所以Mark-Sweep在标记阶段遍历堆中的所有对象，标记活着的对象，在随后的清除阶段，只清除未被标记的对象。Mark-Sweep最大的问题是一次标记清除后，内存空间会出现不连续的状态，Mark-Compact作为改进，会将活着的对象移动整理。")]),t._v(" "),a("p",[t._v("在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代内存配置较小，存活对象通常较少，所以全停顿影响不大。对于老生代 ，一次全量Mark-Sweep-Compact会造成比较长时间的全停顿。所以会有增量标记(incremental marking)，延迟清理(lazy sweeping)和增量整理(incremental compaction)。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("回收算法")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Scavenge")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Mark-Sweep")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Mark-Compact")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("速度")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("最快")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("中等")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("最慢")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("空间开销")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("双倍空间")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("少(有碎片)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("少(无碎片)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("是否移动对象")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("否")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("是")])])])]),t._v(" "),a("h2",{attrs:{id:"常见内存泄露原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见内存泄露原因"}},[t._v("#")]),t._v(" 常见内存泄露原因")]),t._v(" "),a("h3",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),a("p",[t._v("通常会用一个对象作为缓存，但是这个缓存缺乏一个过期机制，可能会随着运行不断增长。")]),t._v(" "),a("p",[t._v("解决方案：使用LRU、LFU这种带有过期机制的缓存，或者直接使用Redis、Memcached这种缓存解决方案。")]),t._v(" "),a("h3",{attrs:{id:"队列消费不及时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列消费不及时"}},[t._v("#")]),t._v(" 队列消费不及时")]),t._v(" "),a("p",[t._v("JS自行实现队列，当消费速度小于入队速度，就会内存泄漏。")]),t._v(" "),a("p",[t._v("可以对队列长度进行监控，或者添加超时机制。也可以使用开源的消息队列如Kafka。")])])}),[],!1,null,null,null);e.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{456:function(t,a,e){"use strict";e.r(a);var i=e(42),n=Object(i.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"a-functional-approach-to-java"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-functional-approach-to-java"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://book.douban.com/subject/36730694/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A Functional Approach to Java"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"an-introduction-to-functional-programming"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#an-introduction-to-functional-programming"}},[t._v("#")]),t._v(" An Introduction to Functional Programming")]),t._v(" "),e("h3",{attrs:{id:"functional-programming-concepts"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-programming-concepts"}},[t._v("#")]),t._v(" Functional Programming Concepts")]),t._v(" "),e("h4",{attrs:{id:"pure-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pure-functions"}},[t._v("#")]),t._v(" Pure Functions")]),t._v(" "),e("p",[t._v("Pure functions have two elemental guarantees:")]),t._v(" "),e("ul",[e("li",[t._v("The same input will always create the same output")]),t._v(" "),e("li",[t._v("They are self-contained without any kind of side effect")])]),t._v(" "),e("h4",{attrs:{id:"referential-transparency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#referential-transparency"}},[t._v("#")]),t._v(" Referential Transparency")]),t._v(" "),e("p",[t._v("You can replace pure functions with their respective evaluated result for any furthur invocations without changing the behavior of your program.")]),t._v(" "),e("h4",{attrs:{id:"immutability"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#immutability"}},[t._v("#")]),t._v(" Immutability")]),t._v(" "),e("p",[t._v("With immutability, data structures can no longer change after their initialization. By never changing, they are always consistent, side-effect-free, predictable, and easier to reason with. Like pure functions, their usage is safe in concurrent and parallel environments without the usual issues of unsynchronized access or out-of-process state changes.")]),t._v(" "),e("h4",{attrs:{id:"first-class-and-higher-order-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#first-class-and-higher-order-functions"}},[t._v("#")]),t._v(" First-Class and Higher-Order Functions")]),t._v(" "),e("p",[t._v("Functions need to be assignable to variables and be used as arguments and return values in other functions and expressions.")]),t._v(" "),e("p",[t._v("Higher-order functions use this first-class citizenship to accept functions as arguments or return a function as their result, or both.")]),t._v(" "),e("h4",{attrs:{id:"functional-composition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-composition"}},[t._v("#")]),t._v(" Functional Composition")]),t._v(" "),e("h4",{attrs:{id:"currying"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#currying"}},[t._v("#")]),t._v(" Currying")]),t._v(" "),e("h4",{attrs:{id:"partial-function-application"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partial-function-application"}},[t._v("#")]),t._v(" Partial Function Application")]),t._v(" "),e("p",[t._v("Partial function application is the process of creating a new function by providing only a subset of the required arguments to an existing one.")]),t._v(" "),e("h4",{attrs:{id:"lazy-evaluation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lazy-evaluation"}},[t._v("#")]),t._v(" Lazy Evaluation")]),t._v(" "),e("p",[t._v("Lazy evaluation is an evaluation strategy that delays the evaluation of an expression until its result is literally needed by separating the concerns of how you create an expression from when you actually use it.")]),t._v(" "),e("h3",{attrs:{id:"advantages-of-functional-programming"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#advantages-of-functional-programming"}},[t._v("#")]),t._v(" Advantages of Functional Programming")]),t._v(" "),e("ul",[e("li",[t._v("Simplicity")]),t._v(" "),e("li",[t._v("Consistency")]),t._v(" "),e("li",[t._v("(Mathmatical) correctness")]),t._v(" "),e("li",[t._v("Safer concurrency")]),t._v(" "),e("li",[t._v("Modularity")]),t._v(" "),e("li",[t._v("Testability")])]),t._v(" "),e("h2",{attrs:{id:"functional-java"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-java"}},[t._v("#")]),t._v(" Functional Java")]),t._v(" "),e("ul",[e("li",[t._v("Functional interface are concrete types and representations of Java lambdas")]),t._v(" "),e("li",[t._v("Lambda expressions are not syntactic sugar to anonymous classes")]),t._v(" "),e("li",[t._v("Outside variables need to be effectively final to be used in lambdas, but this makes only the references immutable, not the undelying data structure.")]),t._v(" "),e("li",[t._v("Method references are a concise altenative for matching method signatures and lambda definitions.")])]),t._v(" "),e("h2",{attrs:{id:"functional-interfaces-of-the-jdk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-interfaces-of-the-jdk"}},[t._v("#")]),t._v(" Functional Interfaces of the JDK")]),t._v(" "),e("p",[t._v("Big Four Functional Interface Variants:")]),t._v(" "),e("ul",[e("li",[t._v("Functions")]),t._v(" "),e("li",[t._v("Consumers")]),t._v(" "),e("li",[t._v("Suppliers")]),t._v(" "),e("li",[t._v("Predicates")])]),t._v(" "),e("p",[t._v("Function Composition")]),t._v(" "),e("ul",[e("li",[t._v("Function\n"),e("ul",[e("li",[t._v("compose")]),t._v(" "),e("li",[t._v("andThen")])])]),t._v(" "),e("li",[t._v("Predicate\n"),e("ul",[e("li",[t._v("and")]),t._v(" "),e("li",[t._v("or")]),t._v(" "),e("li",[t._v("negate")])])]),t._v(" "),e("li",[t._v("Consumer\n"),e("ul",[e("li",[t._v("andThen")])])])]),t._v(" "),e("h2",{attrs:{id:"immutability-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#immutability-2"}},[t._v("#")]),t._v(" Immutability")]),t._v(" "),e("ul",[e("li",[t._v("String")]),t._v(" "),e("li",[t._v("Immutable Collections\n"),e("ul",[e("li",[t._v("Unmodifiable Collections.\nStatic methods like "),e("code",[t._v("Collections.unmodifiableList")]),t._v(" and "),e("code",[t._v("Collections.unmodifiableSet")]),t._v(' only provide "unmodifiable view" , but the underlying Collection is still modifiable')]),t._v(" "),e("li",[t._v("Immutable Collection factory methods\n"),e("ul",[e("li",[t._v("List.of")]),t._v(" "),e("li",[t._v("Set.of")]),t._v(" "),e("li",[t._v("Map.of")])])]),t._v(" "),e("li",[t._v("Immutable copies (Instead of being a mere view, copyOf creates a new container, holding its own references to the elements )\n"),e("ul",[e("li",[t._v("List.copyOf")]),t._v(" "),e("li",[t._v("Set.copyOf")]),t._v(" "),e("li",[t._v("Map.copyOf")])])])])]),t._v(" "),e("li",[t._v("Primitive Wrapper")]),t._v(" "),e("li",[t._v("Immutable Math\n"),e("ul",[e("li",[t._v("BigInteger")]),t._v(" "),e("li",[t._v("BigDecimal")])])]),t._v(" "),e("li",[t._v("java.time")]),t._v(" "),e("li",[t._v("Records")])])])}),[],!1,null,null,null);a.default=n.exports}}]);